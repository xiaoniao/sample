
1、软件开发的根本就在于降低软件复杂性。因此需要采用可复用的软件设计模式，选择合适的软件架构来搭建自己的系统。这当中就用到了消息队列。


需求：
    1、你需要将同一条消息发送给多个感兴趣的系统，同时又需要让系统只接受符合特定模式的消息。
    2、你开始觉得系统当中的同步处理方式严重影响了吞吐量，想把用户订单处理、消息通知等都修改成异步处理的方式。
    3、你开始关注系统的高可用性。同事还想实时观测系统当中订单消息的处理速率，以便及时应对峰值压力。
    4、最终要的一点是，使用消息队列并不是『杀鸡焉用牛刀』的问题，而是一种未雨绸缪，随着系统不断眼睛，你终将从消息队列中获益。


RabbitMQ: 实现AMQP协议，支持各种编程语言、各种操作平台、生产者/消费者、Erlang语言编写。

RabbitMQ常用命令：http://blog.csdn.net/u013256816/article/details/53524814



一、消费者和生产者
    RabbitMQ 是一个消息投递服务。

    +---------------+     +----------+     +---------------+
    | Application A | --> |          | --> | Application C |
    +---------------+     | RabbitMQ |     +---------------+
    +---------------+     |          |     +---------------+
    | Application B | --> |          | --> | Application D |
    +---------------+     +----------+     +---------------+

    谁都可以放生产者，也都可以当消费者，在协议中声明。


    消息包含两部分：有效载荷（payload）、标签（label）。有效载荷就是要传输的数据。标签描述了有效载荷，并且决定谁将获得消息的拷贝。

    Rabbit会根据标签把消息发送给感兴趣的接收方。这种通信方式是一种发后即忘（fire and forget）的单向方式。

    消费者：只会接收到有效载荷不会接收到标签，所以消费者并不知道生产者的信息，除非把生产者信息放到有效载荷中。


    信道(channel)
        +-----+        +-----------+
        |     | -----> | channel 1 |
        |     |        +-----------+
        |     |        +-----------+
        | TCP | -----> | channel 2 |
        |     |        +-----------+
        |     |        +-----------+
        |     | -----> | channel 3 |
        +-----+        +-----------+

        信道是建立在真实的TCP连接内的虚拟连接。为了减少TCP开销，每条信道都会被指派一个唯一ID（AMQP库会帮你记住ID）。不论是发布消息、订阅队列或是接受消息，这些动作都是通过信道完成。

        线程启动后会创建一条信道。


        一旦建立到RabbitMQ代理服务器的连接，应用程序将创建多条信道：
            +-------------+     +------------+     +----------+
            |             | <-- | chan_recv  | <-- |          |
            | Application |     +------------+     | RabbitMQ |
            |             |     +------------+     |          |
            |             | --> | chan_sendX | --> |          |
            +-------------+     +------------+     +----------+

二、队列 （交换器、队列、绑定）

    订阅到队列：
        1、basic.consume 持续订阅。
        2、basic.get 订阅一次，接受到消息后，取消订阅。


        一个消费者订阅：立即发送给消费者。
        无消费者订阅：消息在队列中等待。
        多消费者订阅：轮训发送消息，直到其中一个消费者确认收到了消息。

    创建队列：
        消费者和生产者都可以使用 queue.declare 命令创建队列。


三、交换器和绑定

    服务器会根据路由键将消息从交换器路由到队列（路由键 -> 交换器 -> 队列）

    四种类型交换器：
        direct:
            如果路由键匹配的画，消息就被投递到对应的队列。
            服务器必须实现 direct 类型交换器，包含一个空白字符串名称的默认交换器。当生命一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。

        fanout:
            这种类型的交换器会将收到的消息广播到绑定的队列上。消息通信模式：当你发送一条消息到 fanout 交换器时，它会把消息投递给所有附加在此交换器上的队列。

        topic:
            它使得来自不同源头的消息能够到达同一个队列。
            模糊匹配字符串

        header:
            匹配AMQP消息的header而非路由键。和direct交换器相比性能差很多，因此不太实用。

    基于消息的路由键和交换器类型，服务器会决定将消息投递到哪个队列去。

四、多租户模式（虚拟主机和隔离）

    虚拟主机(vhost)和用户和权限管理

    vhost，每一个RabbitMQ服务器都能创建虚拟消息服务器，我们称之为虚拟主机(vhost)，每一个vhost本质是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器和绑定，也拥有自己的权限。

    运行一个Rabbit，按需启动或关闭vhost

    vhost 是 AMQP 概念的基础，必须在连接时进行制定。默认vohost是 "/"。

五、持久化

    在发送消息前，把它的投递模式选项设置为2(永久)、持久化交换器、持久化队列

    AMQP事务 性能差

    发送方确认模式 和事务相仿，你需要告诉Rabbit将信道设置成confirm模式，而且你只能通过重新创建信道来关闭改设置。


六、
    1、发布者：
        1）. 连接到RabbitMQ
        2）. 获取信道
        3）. 声明交换器
        4）. 创建消息
        5）. 发布消息
        6）. 关闭信道
        7）. 关闭连接
    
    2、消费者：
        1）. 连接到RabbitMQ
        2）. 获取信道
        3）. 声明交换器
        4）. 声明队列
        5）. 把队列和交换器绑定起来
        6）. 消费消息
        7）. 关闭信道
        8）. 关闭连接

        队列和交换器生产者消费者都可以创建，这里是作者自己的实现。

    3、使用发送方确认模式来确认投递
    
        因为事务会影响性能，因此推荐使用 publisher confirm 作为消息投递保障的首选方案。


        当信道设置成confirm模式时，发布的每一条消息都会获得唯一的ID。由于一条信道只能被单个线程使用，因为可以确保信道上发布的消息都是连续的。
        因此，RabbitMQ做了一个简单的假设：任意信道上发布的第一条消息将获得ID1，并且信道上接下来的每一条消息的ID都将步进1。也就是说信道上发布的第二条消息将拥有ID2。
        第三条消息将拥有ID3，对信道来说，消息ID是唯一的。所以一旦信道关闭后，你将无法追踪发布在该信道上未完成的发送方确认消息状态。
        这意味着RabbitMQ不必告诉你刚发布的消息ID；你在应用程序内部通过一个计数器来自己追踪。

        TODO

运行和管理RabbitMQ

    管理用户：
        rabbitmqctl list_users
        rabbitmqctl add_user username password
        rabbitmqctl delete_user username
        rabbitmqctl change_password username password

    权限系统：
        度、写、配置

        TODO


日志
    TODO














